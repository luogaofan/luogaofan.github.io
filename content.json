{"meta":{"title":"我的博客","subtitle":"","description":"","author":"地古nier","url":"https://luogaofan.github.io","root":"/"},"posts":[{"tags":[{"name":"ES6","slug":"ES6","permalink":"https://luogaofan.github.io/tags/ES6/"}],"title":"ES6新特性","date":"2019/12/19","text":"介绍ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）在标准ECMA-262中定义的脚本语言规范。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。 ES6(ES2015)Let 和 Const在ES6以前，JS只有var一种声明方式，但是在ES6之后，就多了let跟const这两种方式。用var定义的变量没有块级作用域的概念，而let跟const则会有，因为这三个关键字创建是不一样的. 区别如下： &#123; var a &#x3D; 10 let b &#x3D; 20 const c &#x3D; 30 &#125; a &#x2F;&#x2F; 10 b &#x2F;&#x2F; Uncaught ReferenceError: b is not defined c &#x2F;&#x2F; c is not defined let d &#x3D; 40 const e &#x3D; 50 d &#x3D; 60 d &#x2F;&#x2F; 60 e &#x3D; 70 &#x2F;&#x2F; VM231:1 Uncaught TypeError: Assignment to constant variable. var let const 变量提升 √ × × 全局变量 √ × × 重复声明 √ × × 重新赋值 √ √ × 暂时死区 × √ √ 块作用域 × √ √ 只声明不初始化 √ √ × 类（Class）在ES6之前，如果我们要生成一个实例对象，传统的方法就是写一个构造函数，例子如下： function Person(name, age) &#123; this.name &#x3D; name this.age &#x3D; age &#125; Person.prototype.information &#x3D; function () &#123; return &#39;My name is &#39; + this.name + &#39;, I am &#39; + this.age &#125; 但是在ES6之后，我们只需要写成以下形式： class Person &#123; constructor(name, age) &#123; this.name &#x3D; name this.age &#x3D; age &#125; information() &#123; return &#39;My name is &#39; + this.name + &#39;, I am &#39; + this.age &#125; &#125; 箭头函数（Arrow function）箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 在ES6以前，我们写函数一般是： var list &#x3D; [1, 2, 3, 4, 5, 6, 7] var newList &#x3D; list.map(function (item) &#123; return item * item &#125;) 但是在ES6里，我们可以： const list &#x3D; [1, 2, 3, 4, 5, 6, 7] const newList &#x3D; list.map(item &#x3D;&gt; item * item) 函数参数默认值（Function parameter defaults）在ES6之前，如果我们写函数需要定义初始值的时候，需要这么写： function config (data) &#123; var data &#x3D; data || &#39;data is empty&#39; &#125; 这样看起来也没有问题，但是如果参数的布尔值为falsy时就会出问题，例如我们这样调用config： config(0) config(&#39;&#39;) 那么结果就永远是后面的值 如果我们用函数参数默认值就没有这个问题，写法如下： const config &#x3D; (data &#x3D; &#39;data is empty&#39;) &#x3D;&gt; &#123;&#125; 模板字符串（Template string）在ES6之前，如果我们要拼接字符串，则需要像这样： var name &#x3D; &#39;kris&#39; var age &#x3D; 24 var info &#x3D; &#39;My name is &#39; + this.name + &#39;, I am &#39; + this.age 但是在ES6之后，我们只需要写成以下形式： const name &#x3D; &#39;kris&#39; const age &#x3D; 24 const info &#x3D; &#96;My name is $&#123;name&#125;, I am $&#123;age&#125;&#96; 解构赋值（Destructuring assignment）我们通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 比如我们需要交换两个变量的值，在ES6之前我们可能需要： var a &#x3D; 10 var b &#x3D; 20 var temp &#x3D; a a &#x3D; b b &#x3D; temp 但是在ES6里，我们有： let a &#x3D; 10 let b &#x3D; 20 [a, b] &#x3D; [b, a] 模块化（Module）在ES6之前，JS并没有模块化的概念，有的也只是社区定制的类似CommonJS和AMD之类的规则。例如基于CommonJS的NodeJS： &#x2F;&#x2F; circle.js &#x2F;&#x2F; 输出 const &#123; PI &#125; &#x3D; Math exports.area &#x3D; (r) &#x3D;&gt; PI * r ** 2 exports.circumference &#x3D; (r) &#x3D;&gt; 2 * PI * r &#x2F;&#x2F; index.js &#x2F;&#x2F; 输入 const circle &#x3D; require(&#39;.&#x2F;circle.js&#39;) console.log(&#96;半径为 4 的圆的面积是 $&#123;circle.area(4)&#125;&#96;) 在ES6之后我们则可以写成以下形式： &#x2F;&#x2F; circle.js &#x2F;&#x2F; 输出 const &#123; PI &#125; &#x3D; Math export const area &#x3D; (r) &#x3D;&gt; PI * r ** 2 export const circumference &#x3D; (r) &#x3D;&gt; 2 * PI * r &#x2F;&#x2F; index.js &#x2F;&#x2F; 输入 import &#123; area &#125; &#x3D; &#39;.&#x2F;circle.js&#39; console.log(&#96;半径为 4 的圆的面积是: $&#123;area(4)&#125;&#96;) 扩展操作符（Spread operator）扩展操作符可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。比如在ES5的时候，我们要对一个数组的元素进行相加，在不使用reduce或者reduceRight的场合，我们需要： function sum(x, y, z) &#123; return x + y + z; &#125; var list &#x3D; [5, 6, 7] var total &#x3D; sum.apply(null, list) 但是如果我们使用扩展操作符，只需要如下： const sum &#x3D; (x, y, z) &#x3D;&gt; x + y + z const list &#x3D; [5, 6, 7] const total &#x3D; sum(...list) 但是如果我们使用扩展操作符，只需要如下： const sum &#x3D; (x, y, z) &#x3D;&gt; x + y + z const list &#x3D; [5, 6, 7] const total &#x3D; sum(...list) 非常的简单，但是要注意的是扩展操作符只能用于可迭代对象 如果是下面的情况，是会报错的： var obj &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;&#125; var array &#x3D; [...obj] &#x2F;&#x2F; TypeError: obj is not iterable 对象属性简写（Object attribute shorthand）在ES6之前，如果我们要将某个变量赋值为同样名称的对象元素，则需要： var cat &#x3D; &#39;Miaow&#39; var dog &#x3D; &#39;Woof&#39; var bird &#x3D; &#39;Peet peet&#39; var someObject &#x3D; &#123; cat: cat, dog: dog, bird: bird &#125; 但是在ES6里我们就方便很多： let cat &#x3D; &#39;Miaow&#39; let dog &#x3D; &#39;Woof&#39; let bird &#x3D; &#39;Peet peet&#39; let someObject &#x3D; &#123; cat, dog, bird &#125; console.log(someObject) &#x2F;&#x2F;&#123; &#x2F;&#x2F; cat: &quot;Miaow&quot;, &#x2F;&#x2F; dog: &quot;Woof&quot;, &#x2F;&#x2F; bird: &quot;Peet peet&quot; &#x2F;&#x2F;&#125; PromisePromise 是ES6提供的一种异步解决方案，比回调函数更加清晰明了。Promise 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是： 等待中（pending）完成了 （resolved）拒绝了（rejected） 这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变 new Promise((resolve, reject) &#x3D;&gt; &#123; resolve(&#39;success&#39;) &#x2F;&#x2F; 无效 reject(&#39;reject&#39;) &#125;) 当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的 new Promise((resolve, reject) &#x3D;&gt; &#123; console.log(&#39;new Promise&#39;) resolve(&#39;success&#39;) &#125;) console.log(&#39;finifsh&#39;) &#x2F;&#x2F; new Promise -&gt; finifsh Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装 Promise.resolve(1) .then(res &#x3D;&gt; &#123; console.log(res) &#x2F;&#x2F; &#x3D;&gt; 1 return 2 &#x2F;&#x2F; 包装成 Promise.resolve(2) &#125;) .then(res &#x3D;&gt; &#123; console.log(res) &#x2F;&#x2F; &#x3D;&gt; 2 &#125;) 当然了，Promise 也很好地解决了回调地狱的问题，例如： ajax(url, () &#x3D;&gt; &#123; &#x2F;&#x2F; 处理逻辑 ajax(url1, () &#x3D;&gt; &#123; &#x2F;&#x2F; 处理逻辑 ajax(url2, () &#x3D;&gt; &#123; &#x2F;&#x2F; 处理逻辑 &#125;) &#125;) &#125;) 可以改写成： ajax(url) .then(res &#x3D;&gt; &#123; console.log(res) return ajax(url1) &#125;).then(res &#x3D;&gt; &#123; console.log(res) return ajax(url2) &#125;).then(res &#x3D;&gt; console.log(res)) for…offor…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。例子如下： const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; for (const element of array1) &#123; console.log(element) &#125; &#x2F;&#x2F; &quot;a&quot; &#x2F;&#x2F; &quot;b&quot; &#x2F;&#x2F; &quot;c&quot; Symbolsymbol 是一种基本数据类型，Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”new Symbol()”。每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。例子如下： const symbol1 &#x3D; Symbol(); const symbol2 &#x3D; Symbol(42); const symbol3 &#x3D; Symbol(&#39;foo&#39;); console.log(typeof symbol1); &#x2F;&#x2F; &quot;symbol&quot; console.log(symbol3.toString()); &#x2F;&#x2F; &quot;Symbol(foo)&quot; console.log(Symbol(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; Symbol(&#39;foo&#39;)); &#x2F;&#x2F; false 迭代器（Iterator）/ 生成器（Generator）迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。一旦创建，迭代器对象可以通过重复调用next()显式地迭代，从而获取该对象每一级的值，直到迭代完，返回{ value: undefined, done: true }虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 生成器函数使用 function*语法编写。 最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。 通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。可以根据需要多次调用该函数，并且每次都返回一个新的Generator，但每个Generator只能迭代一次。所以我们可以有以下例子： function* makeRangeIterator(start &#x3D; 0, end &#x3D; Infinity, step &#x3D; 1) &#123; for (let i &#x3D; start; i &lt; end; i +&#x3D; step) &#123; yield i; &#125; &#125; var a &#x3D; makeRangeIterator(1,10,2) a.next() &#x2F;&#x2F; &#123;value: 1, done: false&#125; a.next() &#x2F;&#x2F; &#123;value: 3, done: false&#125; a.next() &#x2F;&#x2F; &#123;value: 5, done: false&#125; a.next() &#x2F;&#x2F; &#123;value: 7, done: false&#125; a.next() &#x2F;&#x2F; &#123;value: 9, done: false&#125; a.next() &#x2F;&#x2F; &#123;value: undefined, done: true&#125; Set/WeakSetSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。所以我们可以通过Set实现数组去重 const numbers &#x3D; [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5] console.log([...new Set(numbers)]) &#x2F;&#x2F; [2, 3, 4, 5, 6, 7, 32] WeakSet 结构与 Set 类似，但区别有以下两点： WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以。WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素。 所以代码如下： var ws &#x3D; new WeakSet() var obj &#x3D; &#123;&#125; var foo &#x3D; &#123;&#125; ws.add(window) ws.add(obj) ws.has(window) &#x2F;&#x2F; true ws.has(foo) &#x2F;&#x2F; false, 对象 foo 并没有被添加进 ws 中 ws.delete(window) &#x2F;&#x2F; 从集合中删除 window 对象 ws.has(window) &#x2F;&#x2F; false, window 对象已经被删除了 ws.clear() &#x2F;&#x2F; 清空整个 WeakSet 对象 Map/WeakMapMap 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。例子如下，我们甚至可以使用NaN来作为键值： var myMap &#x3D; new Map(); myMap.set(NaN, &quot;not a number&quot;); myMap.get(NaN); &#x2F;&#x2F; &quot;not a number&quot; var otherNaN &#x3D; Number(&quot;foo&quot;); myMap.get(otherNaN); &#x2F;&#x2F; &quot;not a number&quot; WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。跟Map的区别与Set跟WeakSet的区别相似，具体代码如下： var wm1 &#x3D; new WeakMap(), wm2 &#x3D; new WeakMap(), wm3 &#x3D; new WeakMap(); var o1 &#x3D; &#123;&#125;, o2 &#x3D; function()&#123;&#125;, o3 &#x3D; window; wm1.set(o1, 37); wm1.set(o2, &quot;azerty&quot;); wm2.set(o1, o2); &#x2F;&#x2F; value可以是任意值,包括一个对象 wm2.set(o3, undefined); wm2.set(wm1, wm2); &#x2F;&#x2F; 键和值可以是任意对象,甚至另外一个WeakMap对象 wm1.get(o2); &#x2F;&#x2F; &quot;azerty&quot; wm2.get(o2); &#x2F;&#x2F; undefined,wm2中没有o2这个键 wm2.get(o3); &#x2F;&#x2F; undefined,值就是undefined wm1.has(o2); &#x2F;&#x2F; true wm2.has(o2); &#x2F;&#x2F; false wm2.has(o3); &#x2F;&#x2F; true (即使值是undefined) wm3.set(o1, 37); wm3.get(o1); &#x2F;&#x2F; 37 wm3.clear(); wm3.get(o1); &#x2F;&#x2F; undefined,wm3已被清空 wm1.has(o1); &#x2F;&#x2F; true wm1.delete(o1); wm1.has(o1); &#x2F;&#x2F; false Proxy/ReflectProxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy 的方法相同。Reflect不是一个函数对象，因此它是不可构造的。Proxy跟Reflect是非常完美的配合，例子如下： const observe &#x3D; (data, callback) &#x3D;&gt; &#123; return new Proxy(data, &#123; get(target, key) &#123; return Reflect.get(target, key) &#125;, set(target, key, value, proxy) &#123; callback(key, value); target[key] &#x3D; value; return Reflect.set(target, key, value, proxy) &#125; &#125;) &#125; const FooBar &#x3D; &#123; open: false &#125;; const FooBarObserver &#x3D; observe(FooBar, (property, value) &#x3D;&gt; &#123; property &#x3D;&#x3D;&#x3D; &#39;open&#39; &amp;&amp; value ? console.log(&#39;FooBar is open!!!&#39;) : console.log(&#39;keep waiting&#39;); &#125;); console.log(FooBarObserver.open) &#x2F;&#x2F; false FooBarObserver.open &#x3D; true &#x2F;&#x2F; FooBar is open!!! 当然也不是什么都可以被代理的，如果对象带有configurable: false 跟writable: false 属性，则代理失效。 Regex对象的扩展正则新增符号i 修饰符 &#x2F;&#x2F; i 修饰符 &#x2F;[a-z]&#x2F;i.test(&#39;\\u212A&#39;) &#x2F;&#x2F; false &#x2F;[a-z]&#x2F;iu.test(&#39;\\u212A&#39;) &#x2F;&#x2F; true y修饰符 &#x2F;&#x2F; y修饰符 var s &#x3D; &#39;aaa_aa_a&#39;; var r1 &#x3D; &#x2F;a+&#x2F;g; var r2 &#x3D; &#x2F;a+&#x2F;y; r1.exec(s) &#x2F;&#x2F; [&quot;aaa&quot;] r2.exec(s) &#x2F;&#x2F; [&quot;aaa&quot;] r1.exec(s) &#x2F;&#x2F; [&quot;aa&quot;] r2.exec(s) &#x2F;&#x2F; null String.prototype.flags &#x2F;&#x2F; 查看RegExp构造函数的修饰符 var regex &#x3D; new RegExp(&#39;xyz&#39;, &#39;i&#39;) regex.flags &#x2F;&#x2F; &#39;i&#39; unicode模式 var s &#x3D; &#39;𠮷&#39; &#x2F;^.$&#x2F;.test(s) &#x2F;&#x2F; false &#x2F;^.$&#x2F;u.test(s) &#x2F;&#x2F; true u转义 &#x2F;&#x2F; u转义 &#x2F;\\,&#x2F; &#x2F;&#x2F; &#x2F;\\,&#x2F; &#x2F;\\,&#x2F;u &#x2F;&#x2F; 报错 没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。 引用 const RE_TWICE &#x3D; &#x2F;^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;$&#x2F;; RE_TWICE.test(&#39;abc!abc&#39;) &#x2F;&#x2F; true RE_TWICE.test(&#39;abc!ab&#39;) &#x2F;&#x2F; false const RE_TWICE &#x3D; &#x2F;^(?&lt;word&gt;[a-z]+)!\\1$&#x2F;; RE_TWICE.test(&#39;abc!abc&#39;) &#x2F;&#x2F; true RE_TWICE.test(&#39;abc!ab&#39;) &#x2F;&#x2F; false 字符串方法的实现改为调用RegExp方法 String.prototype.match 调用 RegExp.prototype[Symbol.match]String.prototype.replace 调用 RegExp.prototype[Symbol.replace]String.prototype.search 调用 RegExp.prototype[Symbol.search]String.prototype.split 调用 RegExp.prototype[Symbol.split] 正则新增属性 RegExp.prototype.sticky 表示是否有y修饰符 &#x2F;hello\\d&#x2F;y.sticky &#x2F;&#x2F; true RegExp.prototype.flags获取修饰符 &#x2F;abc&#x2F;ig.flags &#x2F;&#x2F; &#39;gi&#39; Math对象的扩展 二进制表示法 : 0b或0B开头表示二进制(0bXX或0BXX) 二进制表示法 : 0b或0B开头表示二进制(0bXX或0BXX) 八进制表示法 : 0o或0O开头表示二进制(0oXX或0OXX) Number.EPSILON : 数值最小精度 Number.MIN_SAFE_INTEGER : 最小安全数值(-2^53) Number.MAX_SAFE_INTEGER : 最大安全数值(2^53) Number.parseInt() : 返回转换值的整数部分 Number.parseFloat() : 返回转换值的浮点数部分 Number.isFinite() : 是否为有限数值 Number.isNaN() : 是否为NaN Number.isInteger() : 是否为整数 Number.isSafeInteger() : 是否在数值安全范围内 Math.trunc() : 返回数值整数部分 Math.sign() : 返回数值类型(正数1、负数-1、零0) Math.cbrt() : 返回数值立方根 Math.clz32() : 返回数值的32位无符号整数形式 Math.imul() : 返回两个数值相乘 Math.fround() : 返回数值的32位单精度浮点数形式 Math.hypot() : 返回所有数值平方和的平方根 Math.expm1() : 返回e^n - 1 Math.log1p() : 返回1 + n的自然对数(Math.log(1 + n)) Math.log10() : 返回以10为底的n的对数 Math.log2() : 返回以2为底的n的对数 Math.sinh() : 返回n的双曲正弦 Math.cosh() : 返回n的双曲余弦 Math.tanh() : 返回n的双曲正切 Math.asinh() : 返回n的反双曲正弦 Math.acosh() : 返回n的反双曲余弦 Math.atanh() : 返回n的反双曲正切 Array对象的扩展 Array.prototype.from：转换具有Iterator接口的数据结构为真正数组，返回新数组。 console.log(Array.from(&#39;foo&#39;)) &#x2F;&#x2F; [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;] console.log(Array.from([1, 2, 3], x &#x3D;&gt; x + x)) &#x2F;&#x2F; [2, 4, 6] Array.prototype.of()：转换一组值为真正数组，返回新数组。 Array.of(7) &#x2F;&#x2F; [7] Array.of(1, 2, 3) &#x2F;&#x2F; [1, 2, 3] Array(7) &#x2F;&#x2F; [empty, empty, empty, empty, empty, empty] Array(1, 2, 3) &#x2F;&#x2F; [1, 2, 3] Array.prototype.copyWithin()：把指定位置的成员复制到其他位置，返回原数组 const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] console.log(array1.copyWithin(0, 3, 4)) &#x2F;&#x2F; [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] console.log(array1.copyWithin(1, 3)) &#x2F;&#x2F; [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;] Array.prototype.find()：返回第一个符合条件的成员 const array1 &#x3D; [5, 12, 8, 130, 44] const found &#x3D; array1.find(element &#x3D;&gt; element &gt; 10) console.log(found) &#x2F;&#x2F; 12 Array.prototype.findIndex()：返回第一个符合条件的成员索引值 const array1 &#x3D; [5, 12, 8, 130, 44] const isLargeNumber &#x3D; (element) &#x3D;&gt; element &gt; 13 console.log(array1.findIndex(isLargeNumber)) &#x2F;&#x2F; 3 Array.prototype.fill()：根据指定值填充整个数组，返回原数组 const array1 &#x3D; [1, 2, 3, 4] console.log(array1.fill(0, 2, 4)) &#x2F;&#x2F; [1, 2, 0, 0] console.log(array1.fill(5, 1)) &#x2F;&#x2F; [1, 5, 5, 5] console.log(array1.fill(6)) &#x2F;&#x2F; [6, 6, 6, 6] Array.prototype.keys()：返回以索引值为遍历器的对象 const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const iterator &#x3D; array1.keys() for (const key of iterator) &#123; console.log(key) &#125; &#x2F;&#x2F; 0 &#x2F;&#x2F; 1 &#x2F;&#x2F; 2 Array.prototype.values()：返回以属性值为遍历器的对象 const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const iterator &#x3D; array1.values() for (const key of iterator) &#123; console.log(key) &#125; &#x2F;&#x2F; a &#x2F;&#x2F; b &#x2F;&#x2F; c Array.prototype.entries()：返回以索引值和属性值为遍历器的对象 const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const iterator &#x3D; array1.entries() console.log(iterator.next().value) &#x2F;&#x2F; [0, &quot;a&quot;] console.log(iterator.next().value) &#x2F;&#x2F; [1, &quot;b&quot;] 数组空位：ES6明确将数组空位转为undefined或者empty Array.from([&#39;a&#39;,,&#39;b&#39;]) &#x2F;&#x2F; [ &quot;a&quot;, undefined, &quot;b&quot; ] [...[&#39;a&#39;,,&#39;b&#39;]] &#x2F;&#x2F; [ &quot;a&quot;, undefined, &quot;b&quot; ] Array(3) &#x2F;&#x2F; [empty × 3] [,&#39;a&#39;] &#x2F;&#x2F; [empty, &quot;a&quot;]","permalink":"https://luogaofan.github.io/2019/12/19/ES6%E6%96%B0%E7%89%B9%E6%80%A7/","photos":[]},{"tags":[{"name":"情感","slug":"情感","permalink":"https://luogaofan.github.io/tags/%E6%83%85%E6%84%9F/"}],"title":"人生，该放下的，别珍惜","date":"2019/12/13","text":"即是放下，也是拥有。放下，不是放弃。 家庭，事业，友情，爱情，亲情……并不需要放弃，放下的仅仅是心中的执念而已；拿起也是放下，世间本来无一物，何处惹尘埃。 看破，放下，自在。 万物皆为我们所用，但非我们所属，我们要抛弃的是一切的执着，淡泊明心，放下，不绝望于人生的苦，也不执着于人生之乐。 放下执念，看淡得失，才能品尝幸福。有些事，不想发生，却不得不接受。有些人，不愿失去，却不得不放手。 放下，是一种理解；得到，是一种感恩。人生，是一种未来，也是一种不在意，还有一种放不下。但是我们必须要记住，如果想改变别人，那么我们必须先改变自己。 人生中有许多的无能为力，我们要学会适应这个多变的世界，只有拿得起，才能放得下，看得开，我们才能读懂人生的真谛。 每一个瞬间，都是人生最贵的碎片，每一个努力，都可以换来更好的未来。风筝断了线，但是人生还有缘，努力吧，别辜负了别人的心，别担心自己的未来，该放下的，别珍惜。 我们既要珍惜缘分，更要看淡得失，聚散随缘，要知道，遗憾才是生活，无常才是人生。 放下是一种解脱，是一种顿悟。有时候我们低头，是为了看准自己脚下的路；累与不累，取决于自己的心态，把事情理清楚，才能告别烦恼，把无谓的痛苦扔掉，快乐才有地方起舞。 努力的改变自己的心态，调节自己的心情，学会在平静中接受现实，学会对自己说声顺其自然，学会坦然面对厄运，学会积极的看待人生，学会凡事都往好处想。放下过去，我们才能过得更幸福。 放下，便是重生；舍弃，便是拥有，别懂得太晚。你若舍得，谁都不是唯一，痛苦将不再纠缠；你若看淡，什么都可以放下，再好亦会失去；你若想开，万事皆是轮回，哪怕风轻云淡。 人生不管是放下和放不下，只要我们还活着，放下和拿起就会贯穿我们的一生，而该思考和记住的就是，放下该放下，拿起能拿起的，舍当舍的，得当得的，用心活着面对一切将面对，一切都会过去，让心静下来，世界就是美好的。 世上本无事，庸人自扰之，人生多少事，都付笑谈中。","permalink":"https://luogaofan.github.io/2019/12/13/%E4%BA%BA%E7%94%9F%EF%BC%8C%E8%AF%A5%E6%94%BE%E4%B8%8B%E7%9A%84%EF%BC%8C%E5%88%AB%E7%8F%8D%E6%83%9C/","photos":[]},{"tags":[{"name":"ES6","slug":"ES6","permalink":"https://luogaofan.github.io/tags/ES6/"}],"title":"ES6 Promise 对象","date":"2019/12/11","text":"概述是异步编程的一种解决方案。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 Promise 状态状态的特点Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。 Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型） const p1 &#x3D; new Promise(function(resolve,reject)&#123; resolve(&#39;success1&#39;); resolve(&#39;success2&#39;); &#125;); const p2 &#x3D; new Promise(function(resolve,reject)&#123; resolve(&#39;success3&#39;); reject(&#39;reject&#39;); &#125;); p1.then(function(value)&#123; console.log(value); &#x2F;&#x2F; success1 &#125;); p2.then(function(value)&#123; console.log(value); &#x2F;&#x2F; success3 &#125;); 状态的缺点无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 then 方法then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。 then 方法的特点在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。 const p &#x3D; new Promise(function(resolve,reject)&#123; resolve(&#39;success&#39;); &#125;); p.then(function(value)&#123; console.log(value); &#125;); console.log(&#39;first&#39;); &#x2F;&#x2F; first &#x2F;&#x2F; success 通过 .then 形式添加的回调函数，不论什么时候，都会被调用。 通过多次调用 .then ，可以添加多个回调函数，它们会按照插入顺序并且独立运行。 const p &#x3D; new Promise(function(resolve,reject)&#123; resolve(1); &#125;).then(function(value)&#123; &#x2F;&#x2F; 第一个then &#x2F;&#x2F; 1 console.log(value); return value * 2; &#125;).then(function(value)&#123; &#x2F;&#x2F; 第二个then &#x2F;&#x2F; 2 console.log(value); &#125;).then(function(value)&#123; &#x2F;&#x2F; 第三个then &#x2F;&#x2F; undefined console.log(value); return Promise.resolve(&#39;resolve&#39;); &#125;).then(function(value)&#123; &#x2F;&#x2F; 第四个then &#x2F;&#x2F; resolve console.log(value); return Promise.reject(&#39;reject&#39;); &#125;).then(function(value)&#123; &#x2F;&#x2F; 第五个then &#x2F;&#x2F;reject:reject console.log(&#39;resolve:&#39; + value); &#125;, function(err) &#123; console.log(&#39;reject:&#39; + err); &#125;); then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。 then 方法注意点简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。 注意总是返回或终止 Promise 链。 const p1 &#x3D; new Promise(function(resolve,reject)&#123; resolve(1); &#125;).then(function(result) &#123; p2(result).then(newResult &#x3D;&gt; p3(newResult)); &#125;).then(() &#x3D;&gt; p4()); 创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。 大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error =&gt; console.log(error));","permalink":"https://luogaofan.github.io/2019/12/11/ES6-Promise-%E5%AF%B9%E8%B1%A1/","photos":[]},{"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://luogaofan.github.io/tags/Markdown/"}],"title":"如何写md格式的文档","date":"2019/12/11","text":"Markdown，他是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。下面就是一些编写格式： 一、标题标题其实和HTML中的h系列很像，想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字， 示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体-加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号或者用_包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字** *这是倾斜的文字*&#96; ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个… 示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;这是引用的内容 效果如下: 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： --- *** 效果如下：可以看到，显示效果是一样的。 五、图片语法： ![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 **上传本地图片直接拖进去 六、超链接语法： [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： [百度](http:&#x2F;&#x2F;baidu.com) 效果如下： 百度 七、列表无序列表 语法：无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法：数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 八、表格语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 示例： |表头|表头|表头| |---|:---:|---:| |第一行|第一行|第一行| |第二行|第二行|第二行| |第三行|第三行|第三行| 效果如下： 表头 表头 表头 第一行 第一行 第一行 第二行 第二行 第二行 第三行 第三行 第三行 九、代码语法：单行代码：代码之间分别用一个反引号包起来代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 &#96;代码内容&#96; 以上就是常用的格式.","permalink":"https://luogaofan.github.io/2019/12/11/%E5%A6%82%E4%BD%95%E5%86%99md%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E6%A1%A3/","photos":[]},{"tags":[],"title":"我的第一篇博客","date":"2019/12/10","text":"经常会突发奇想的计划着怎么怎么样，却在行动的时候虎头蛇尾了，很难坚持作下去。这或许是很多人都存在的问题。在别人博客上看到：“或许写博客是一个不错的方法”。通过博客，经常来记录一下自己的学习，问题，思路等等。在成长的路上留下自己的足迹，回首时可能是一道专属的风景吧。","permalink":"https://luogaofan.github.io/2019/12/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","photos":["http://shanxi.gqt.org.cn/zyx/ftrq/200902/W020090616427153128814.jpg"]}]}